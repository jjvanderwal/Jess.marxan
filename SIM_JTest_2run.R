# Obtain command line arguments from .sh file

args=(commandArgs(TRUE))

# Evaluate the arguments for use in this script

for(i in 1:length(args)) 
	
	{
		
	eval(parse(text=args[[i]]))
 
	}	
	
#### Iterative Marxan simulations

### Necessary functions as written by JJV

### Function to write things out in binary for linux

twrite = function(x,y) {
  f = file(y,'wb')
  write.table(x,row.names=FALSE,sep=",",quote=FALSE,file=f)
  close(f)
}

twrite2 = function(x,y) {
  f = file(y,'wb')
  write.table(x,row.names=FALSE,sep=",",quote=FALSE,file=f,col.names=FALSE)
  close(f)
}

### Function to write input data files

write.inputs = function(idx) {
  ###make the pu.dat
  pu = aggregate(tdata[,'area'],by=list(id=tdata[,'PU'],status=tdata[,'status']),sum) #aggregate to pu
  colnames(pu)=c('id','status','cost') #add appropriate colnames
  twrite(pu,file.path(idx,"pu.dat"))
  ###make the puorder.dat
  puorder = aggregate(tdata[,'area'],by=list(species=tdata[,'FU'],pu=tdata[,'PU']),sum) #aggregate to pu & fu
  colnames(puorder)=c('species','pu','amount'); puorder = puorder[,c('species','pu','amount')] #add appropriate colnames & reorder
  twrite(puorder,file.path(idx,'/puorder.dat'))
  ###make the sporder.dat
  sporder = puorder
  sporder = sporder[order(sporder[,'species'],sporder[,'pu']),] #reorder for species first
  twrite(sporder,file.path(idx,'/sporder.dat'))
}

### Function to create input directory

create.input.dat = function(od,id,tt) {
  tstr = 'Input file for Annealing program.'
  tstr = c(tstr,'')
  tstr = c(tstr,'This file generated by Inedit.exe.')
  tstr = c(tstr,'written by Ian Ball and Hugh Possingham.')
  tstr = c(tstr,'iball@maths.adelaide.edu.au')
  tstr = c(tstr,'hpossing@maths.adelaide.edu.au')
  tstr = c(tstr,'')
  tstr = c(tstr,'General Parameters')
  # tstr = c(tstr,'VERSION 0.1')
  tstr = c(tstr,'BLM 1')
  tstr = c(tstr,'PROP 0.5')
  tstr = c(tstr,'RANDSEED -1')
  tstr = c(tstr,'NUMREPS 100')
  tstr = c(tstr,'')
  tstr = c(tstr,'Annealing Parameters')
  tstr = c(tstr,'NUMITNS 10000000')
  tstr = c(tstr,'STARTTEMP -1')
  tstr = c(tstr,'NUMTEMP 10000')
  tstr = c(tstr,'')
  tstr = c(tstr,'Cost Threshold')
  tstr = c(tstr,'COSTTHRESH 0.00000000000000E+0000')
  tstr = c(tstr,'THRESHPEN1 1.40000000000000E+0001')
  tstr = c(tstr,'THRESHPEN2 1.00000000000000E+0000')
  tstr = c(tstr,'')
  tstr = c(tstr,'Input Files')
  tstr = c(tstr,paste('INPUTDIR ',id,sep=''))
  tstr = c(tstr,'PUNAME pu.dat')
  tstr = c(tstr,'SPECNAME spec.dat')
  tstr = c(tstr,'PUVSPRNAME puorder.dat')
  # tstr = c(tstr,'MATRIXSPORDERNAME sporder.dat')
  tstr = c(tstr,'')
  tstr = c(tstr,'Save Files')
  tstr = c(tstr,paste('SCENNAME rep',sprintf('%03i',tt),sep=''))
  tstr = c(tstr,'SAVERUN 3')
  tstr = c(tstr,'SAVEBEST 3')
  tstr = c(tstr,'SAVESUMMARY 3')
  tstr = c(tstr,'SAVESCEN 3')
  tstr = c(tstr,'SAVETARGMET 3')
  tstr = c(tstr,'SAVESUMSOLN 3')
  tstr = c(tstr,'SAVEPENALTY 3')
  tstr = c(tstr,'SAVELOG 2')
  tstr = c(tstr,paste('OUTPUTDIR ',od,sep=''))
  tstr = c(tstr,'')
  tstr = c(tstr,'Program control.')
  tstr = c(tstr,'RUNMODE 1')
  tstr = c(tstr,'MISSLEVEL 1')
  tstr = c(tstr,'ITIMPTYPE 0')
  tstr = c(tstr,'HEURTYPE -1')
  tstr = c(tstr,'VERBOSITY 3')
  tstr = c(tstr,'')
  tstr = c(tstr,'SAVESOLUTIONSMATRIX 3')
  return(tstr)
}

create.spec.dat = function() {
  tstr = c("id,prop,spf,name")
  tstr = c(tstr,"11,0.3,30,Bank lagoon")
  tstr = c(tstr,"23,0.3,36,Patch land")
  tstr = c(tstr,"26,0.3,25,Shelf patch-reef complex")
  tstr = c(tstr,"27,0.3,33,Ocean exposed fringing")
  tstr = c(tstr,"29,0.3,41,Lagoon exposed fringing")
  tstr = c(tstr,"36,0.3,41,Shelf terrace")
  tstr = c(tstr,"37,0.3,41,Shelf structure")
  return(tstr)
}

#### Necessary functions above here

################################################################################

#### Things that need to be command arguments

xx = as.numeric(xx)
xxorig = xx

#it = '001' # The simulation number, used to create directories

### Directories and libraries

library(SDMTools)

basedir = '/home/jc152199/Others/JC/BASESIM/'
indir = paste('/home/jc152199/Others/JC/BASESIM/Investigate',xx,'PU/ReplicateRun',it,'/',sep='')
dir.create(indir,recursive=T)
setwd(indir)

### Copy the Marxan run file from basedir to indir

system(paste('cp ',basedir,'MarOpt_v243_Linux64 ',indir,'MarOpt_v243_Linux64',sep=''))

### Change permission on Marxan run file

system(paste('chmod +x ./MarOpt_v243_Linux64',sep=''))

### Read in ASCIIs

puasc = read.asc(paste(basedir,'dummyasciis/pu2_ascii.asc',sep=''))
fuasc = read.asc(paste(basedir,'dummyasciis/fu2_ascii.asc',sep=''))
muasc = read.asc(paste(basedir,'dummyasciis/mu2_ascii.asc',sep=''))

### Create pos and extract data from maps

pos = as.data.frame(which(is.finite(puasc),arr.ind=T))

### Get easting / northings from the maps

pos$lat = getXYcoords(puasc)$y[pos$col]
pos$long = getXYcoords(puasc)$x[pos$row]

### Create tdata from ASCII files

tdata = matrix(NA,nrow=nrow(pos),ncol=8)

colnames(tdata) = c('GUID','lat','lon','PU','MU','FU','area','status')

tdata[,'GUID'] = 1:nrow(pos)

### Extract data onto tdata

tdata[,'PU'] = extract.data(cbind(pos$long,pos$lat),puasc)
tdata[,'MU'] = extract.data(cbind(pos$long,pos$lat),muasc)
tdata[,'FU'] = extract.data(cbind(pos$long,pos$lat),fuasc)

### Put lat / long from pos onto tdata

tdata[,'lat'] = pos$lat
tdata[,'lon'] = pos$long

### Change area to 900 (cell size of map)

tdata[,'area'] = rep(900,nrow(pos))

### Change status on tdata

tdata[,'status'] = rep(0,nrow(pos))

### Read in created rarity table

rarity = read.csv(paste(basedir,'PU1_L3_rarity_values.csv',sep=''), header=T)
rarity = rarity[,c(1,3)] # Keep only necessary columns

# Read in shared boundary files

mubound = read.csv(paste(basedir,'mu_bounds.csv',sep=''), header=T)
pubound = read.csv(paste(basedir,'puboundlength2.csv',sep=''), header=T)

### Create a table of thresholds based on planning unit size

putf = aggregate(tdata[,'area'],by=list(PU=tdata[,'PU']), FUN=sum)
names(putf)[2] = 'PUthresh'
putf$PUthresh = putf$PUthresh/2

### Do the initial Marxan run

### Start by creating directories

id = paste('input',sprintf('%03i',1),sep=''); dir.create(id)
od = paste('output',sprintf('%03i',1),sep=''); dir.create(od) 

### Create the input files
		
write.inputs(id)
twrite2(create.input.dat(od,id,1),paste('input',sprintf('%03i',1),'.dat',sep=''))
twrite2(create.spec.dat(),file.path(id,'/spec.dat'))
		
### Run Marxan
		
#system(command=paste('./MarOpt_v243_Linux64 input',sprintf('%03i',1),'.dat -s ',sep=''))

### Create the objective table
### This must be done to meet the condition of the while loop on the first iteration

### Updated conservation features/rarity table
# Remaining objectives to be calculated based on aggregating information in 'status' column in tdata

objtable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU']),sum)

# Create fixed objective column

objtable[,'objarea'] = objtable[,2]*0.3

# Objective as percentage

objtable[,'remainobj'] = (objtable[,'objarea']/objtable[,'x'])*100

# Add rarity values in

objtable[,'rarity'] = rarity[match(objtable[,'FU'], rarity$L3_CODE),2]

# Change summed area heading to more intuitive one

names(objtable)[2] = 'sumarea'
			
### Loop through running Marxan multiple times, each subsequent run is based on output of prior run

ii=2

### Report progress

cat('\nInitial Marxan Run Completed\n')

### Create a list of PUids which can possibly be investigated

pu2i = seq(1:2000)

### Begin iteratively running Marxan until all objectives have been met

		while(sum(objtable$remainobj)>0) 
		
			{

			### Report progress

			cat('\nReading In Data From Marxan Iteration ',ii-1,'\n')
			
			### Start by creating directories

			id = paste('input',sprintf('%03i',ii),sep=''); dir.create(id)
			od = paste('output',sprintf('%03i',ii),sep=''); dir.create(od) 
			
			# Read in input files from prior run, do some calculations and then run Marxan again
	
			### Read in the best solution 
			
			best = read.csv(paste('output',sprintf('%03i',ii-1),'/rep',sprintf('%03i',ii-1),'_best.csv',sep=''))
			best = best[which(best$PUID %in% pu2i),]
			
			### Read in all solutions
			
			ssoln = read.csv(paste('output',sprintf('%03i',ii-1),'/rep',sprintf('%03i',ii-1),'_ssoln.csv',sep=''))
			
			# Extract all selected PUs from best solution (SOLUTION == 1)
			
			best = subset(best, SOLUTION ==1)
			
			# Append selection frequency values
			
			best.ssoln = ssoln[which(ssoln$planning_unit %in% best$PUID),]
			
			# Merge with best PUs
			
			best$ssoln = best.ssoln[match(best$PUID, best.ssoln$planning_unit),2]
			
			# Reorder bestdf by ssoln now (highest to lowest) to select top x number of PUs
			
			best = best[with(best, order(ssoln,decreasing=TRUE)), ]
			
			## Are there fewer planning units selected in the best solution than units to investigate?
			### If so adjust xx to equal the number of planning units in best solution
			
			if(nrow(best)<xxorig){xx=nrow(best);cat('\nNumber of Planning To Investigate Changed To ',xx,'\n',sep='')} else {xx=xxorig}
			
			# Select the top 'xx' PU's for investigation
			
			investigate = best[1:xx,1]
			
			# Read in selection frequency distribution

    		freqdist = read.csv(paste(basedir,'PU1_adjusted_tabus_freq_dist.csv',sep=''), header=T)

    		# Turn into vector

    		vectfreq = as.vector(freqdist[,1])

    		# Randomly select value - this is our % conversion target for this PU

    		#target = sample(vectfreq, 1, replace=F, prob=NULL)
			target = 75
			
			### Updated conservation features/rarity table
			# Remaining objectives to be calculated based on aggregating information in 'status' column in tdata
			
			objtable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU']),sum)
			
			# Create fixed objective column
			
			objtable[,'objarea'] = objtable[,2]*0.3
			
			# Objective as percentage
			
			objtable[,'remainobj'] = (objtable[,'objarea']/objtable[,'x'])*100
			
			# Add rarity values in
			
			objtable[,'rarity'] = rarity[match(objtable[,'FU'], rarity$L3_CODE),2]

			# Change summed area heading to more intuitive one

			names(objtable)[2] = 'sumarea'
			
			### Create a dataframe of all MU/PU combinations
			
			mupus = data.frame(unique(cbind(tdata[,'MU'],tdata[,'PU'])))
			names(mupus) = c('MU','PU')
			
			### Print
			
			cat('\nObjtable Before Investigations Begin\n',sep='')
			print(objtable)

			### Saving image trying to capture all objects when iii=3 before we enter the investigation loop so we can troubleshoot the bugs
			### Also save the latest version of tdata as another object
			tdataii3 = tdata
			if(ii==3){save.image('All3.Rdata')}
			
			# Loop through planning units from investigate
			
			for (inv in investigate) 
			
				{
				
				### Save
				
				#save.image('All.Rdata')
				
				### Print out investigate
				
				cat('\nUnits To Investigate Are\n',sep='')
				print(investigate)
				
				### Report the unit being investigated
				
				cat('\nBegin Investigating Planning Unit ',inv,'\n',sep='')
				
				### What is the position of this investigative unit in investigate
				
				invpos = which(investigate==inv)
				
				### Save an image
				
				#save.image('All.Rdata')
				
				### If invpos equals 1, continue with locking units in
				
				if(invpos==1)
				
				{
				
				### Report progress
				
				cat('\nInvestigating First Planning Unit\n',sep='')
				
				### Subsetting to a single planning unit	
			
				puinvest = tdata[which(tdata[,'PU']==inv),]
				
				### Subset the combinations of MU and PU by this planning unit
				
				tmupu = mupus[which(mupus$PU==inv),]
			
				# Now want to summarise this by MU ID and FU ID and area
			
				puinvest = aggregate(puinvest[,'area'], by=list(FU=puinvest[,'FU'], MU=puinvest[,'MU'], PU=puinvest[,'PU']),sum)
			
				# Now to assess the conservation value of each intersecting MU
				### To do this, use a loop
			
				### Identify unique MU's in 'puinvest'
			
				umus = unique(puinvest$MU)
			
				### Create a blank object for binding data to
			
				out = NULL
			
				for (umu in umus)
			
					{
					
					### Subset to only the management unit 'umu'
					
					tpu1 = puinvest[which(puinvest$MU==umu),]
					
					### Get the unique feature units from 'tpu1'
					
					ufus = unique(tpu1$FU)
					
					for (ufu in ufus)
						
						{
						
						### Subset to a single feature unit
						
						tobj = objtable[which(objtable$FU==ufu),]
						
						### Do some calculation
						
						value = tobj$remainobj * tobj$rarity
						
						### Bind this data into a dataframe
						
						tout = data.frame(MU=umu,FU=ufu,value=value)
						
						### Bind this data to 'out'
						
						out = rbind(out,tout)
						
						}
					
					}
					
				### Close loop
		
				### Aggregate out by summing all values within MU's
				
				outag = aggregate(out$value,by=list(MU=out$MU),FUN=sum)
				
				### Change a name
				
				names(outag)[2] = 'sumvalue'

				### Reorder 'outag' by conservation value
				
				outag = outag[rev(order(outag$sumvalue)),]
				
				### Print
				
				cat('\nOutAg Before Locking In First MU\n',sep='')
				print(outag)
				
				# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

				tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
				
				### Progress
				
				cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')
				
				### Print
				
				cat('\nOutAg After Locking In First MU\n',sep='')
				print(outag)
				
				### Update newly locked in MU in 'objtable'

				locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
				names(locktable)[3] = 'lockedarea'
				
				### Merge locktable and objtable by FU
				
				mergetable = merge(locktable,objtable,by='FU')
				mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
				
				### Remove FU's from merge table where status is zero, only if they also have some area locked in
				
				out2 = NULL
				
				for (fu in unique(mergetable$FU))
				
					{
					
					### Subset
					
					tm = mergetable[which(mergetable$FU==fu),]
					
					if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
					
					out2 = rbind(out2,tm)
					
					}
					
				objtable = out2
				
				cat('\nObjtable With Locked In MUs Updated\n',sep='')
				print(objtable)
				
				### Calculate proportion of managment units locked in
				### This should be done only for management units intersecting PU inv
				### However, we then calculate area for these MU's across all PU's
				
				### Start by subsetting tdata to only PU 'inv'
				
				ttdata = tdata[which(tdata[,'PU']==inv),]
				
				### Determine the Managment Units which interest PU 'inv'
				
				ttumus = unique(ttdata[,'MU'])
				
				### Subset tdata by only the management units in ttumus
				
				tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

				### Now find the sum of the areas for these management units where status is 2
				
				numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
				
				denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
				### Calculate the area that has been 'locked in'
				
				currentproplocked = (numerator/denominator)*100
				
				### Using a while loop to achieve the target
				
				### Create copies of key tables
				
				outagorig = outag
				
				### Testing line
				
				#check = unique(tdata[,'MU'][which(tdata[,'status']==2)])
				
				### Print
				
				cat('\nNumerator,Denominator, and CPL After Locking In First MU\n',sep='')
				print(numerator)
				print(denominator)
				print(currentproplocked)

				while(currentproplocked<target)
				
					{
					
					### Remove the 'lockedarea' field from objtable, otherwise it will fuck up the merge inside this while loop
					
					objtable = objtable[,-c(2,3)] ############ SEARCH HERE ###########
					
					### Identify the management unit with the highest value
					
					muhv = outag$MU[1]
					
					### Find all the management units which neighbor MUHV
					
					m1 = grep(muhv,mubound[,1])
					m2 = grep(muhv,mubound[,2])
					mpos = mubound[unique(m1,m2),]
					neighbors = unique(c(mpos$MUID1,mpos$MUID2))
					
					### Print
					
					cat('\nAll Neighbors Of MU ',muhv,'\n',sep='')
					print(neighbors)
				
					### Conditional stuff
					
					if(length(unique(outag$MU %in% neighbors))==2) # Not all MU's in outag are niehgbors of muhv
					
						{
						
						cat('\nNot All MUs in Outag Are Neighbors of MUHV\n',sep='')
					
						### Eliminate neighbors from outag
						
						outag = outag[-which(outag$MU %in% neighbors),]
						
						### Print
						
						cat('\nOutAg After Neighbors Are Removed\n',sep='')
						print(outag)
						
						# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

						tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
						
						### Report Progress
						
						cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')

						### Update newly locked in MU in 'objtable'

						locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
						names(locktable)[3] = 'lockedarea'
						
						### Merge locktable and objtable by FU
						
						mergetable = merge(locktable,objtable,by='FU') ##### COLLIN SEARCH HERE #########
						mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
						
						### Remove FU's from merge table where status is zero, only if they also have some area locked in
						
						out2 = NULL
						
						for (fu in unique(mergetable$FU))
						
							{
							
							### Subset
							
							tm = mergetable[which(mergetable$FU==fu),]
							
							if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
							
							out2 = rbind(out2,tm)
							
							}
							
						objtable = out2
						
						### Print
						
						cat('\nObjtable With Locked In MUs Updated\n',sep='')
						print(objtable)
				
						### Calculate proportion of managment units locked in
						### This should be done only for management units interesting PU inv
						### However, we then calculate area for these MU's across all PU's
						
						### Start by subsetting tdata to only PU 'inv'
						
						ttdata = tdata[which(tdata[,'PU']==inv),]
						
						### Determine the Managment Units which interest PU 'inv'
						
						ttumus = unique(ttdata[,'MU'])
						
						### Subset tdata by only the management units in ttumus
						
						tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

						### Now find the sum of the areas for these management units where status is 2
						
						numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
						
						denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
						### Calculate the area that has been 'locked in'
				
						currentproplocked = (numerator/denominator)*100
						
						cat('\nNumerator,Denominator, and CPL\n',sep='')
						print(numerator)
						print(denominator)
						print(currentproplocked)

						### Print out a counter
						
						} else { ### In this instance, the management units in outag are all neighbors
						
						### 
						
						cat('\nAll MUs in OutAg Are Neighbors of MUHV\n',sep='')
						
						### Identify the MU's in tdata which are 'locked in'
						
						lockedunits = unique(tdata[,'MU'][which(tdata[,'status']==2)])
						
						### Recreate outag, by removing only the lockedunits from outagorig
						
						outag = outagorig[-which(outagorig$MU %in% lockedunits),]
						
						### Print
						
						cat('\nOutAg With All Locked In MUs Removed\n',sep='')
						print(outag)
						
						# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

						tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
						
						### Progress
						
						cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')

						### Update newly locked in MU in 'objtable'

						locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
						names(locktable)[3] = 'lockedarea'
						
						### Merge locktable and objtable by FU
						
						mergetable = merge(locktable,objtable,by='FU')
						mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
						
						### Remove FU's from merge table where status is zero, only if they also have some area locked in
						
						out2 = NULL
						
						for (fu in unique(mergetable$FU))
						
							{
							
							### Subset
							
							tm = mergetable[which(mergetable$FU==fu),]
							
							if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
							
							out2 = rbind(out2,tm)
							
							}
							
						objtable = out2
						
						### Print
						
						cat('\nObjtable With Locked In MUs Updated\n',sep='')
						print(objtable)
						
						### Calculate proportion of managment units locked in
						### This should be done only for management units interesting PU inv
						### However, we then calculate area for these MU's across all PU's
						
						### Start by subsetting tdata to only PU 'inv'
						
						ttdata = tdata[which(tdata[,'PU']==inv),]
						
						### Determine the Managment Units which interest PU 'inv'
						
						ttumus = unique(ttdata[,'MU'])
						
						### Subset tdata by only the management units in ttumus
						
						tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

						### Now find the sum of the areas for these management units where status is 23
						
						numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
						
						denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
						### Calculate the area that has been 'locked in'
				
						currentproplocked = (numerator/denominator)*100
						
						### Print out a counter
						
						cat('\nNumerator,Denominator, and CPL\n',sep='')
						print(numerator)
						print(denominator)
						print(currentproplocked)

						} # End of else condition
					
					}
					
				### End of while loop here, i.e. target has been reached for the planning unit 'inv'
			
				### Now calculate the area of all PU's which has been locked in as a result of locking in area for the planning unit 'inv'
				
				pulock = aggregate(tdata[,'area'][which(tdata[,'status']==2)],by=list(PU=tdata[,'PU'][which(tdata[,'status']==2)],status=tdata[,'status'][which(tdata[,'status']==2)]),FUN=sum)
				names(pulock)[3] = 'lockedarea'
				
				cat('\n Area Locked For PUs\n',sep='')
				print(pulock)
				
				
				} else if (invpos>1 & (inv %in% pulock$PU)==F) { # 
				
				### Report progress
				
				cat('\nInvestigating Planning Unit With No Locked In Management Units\n',sep='')
				
				### Remove the fields status and locked area from objtable or they will mess up merging later
				
				objtable = objtable[,-c(2:3)]
				
				### Print
				
				cat('\nObjTable Before Locking In New MUs\n',sep='')
				print(objtable)
				
				### Subsetting to a single planning unit	
			
				puinvest = tdata[which(tdata[,'PU']==inv),]
				
				### Subset the combinations of MU and PU by this planning unit
				
				tmupu = mupus[which(mupus$PU==inv),]
			
				# Now want to summarise this by MU ID and FU ID and area
			
				puinvest = aggregate(puinvest[,'area'], by=list(FU=puinvest[,'FU'], MU=puinvest[,'MU'], PU=puinvest[,'PU']),sum)
			
				# Now to assess the conservation value of each intersecting MU
				### To do this, use a loop
			
				### Identify unique MU's in 'puinvest'
			
				umus = unique(puinvest$MU)
			
				### Create a blank object for binding data to
			
				out = NULL
			
				for (umu in umus)
			
					{
					
					### Subset to only the management unit 'umu'
					
					tpu1 = puinvest[which(puinvest$MU==umu),]
					
					### Get the unique feature units from 'tpu1'
					
					ufus = unique(tpu1$FU)
					
					### Print some stuff
					
					#cat('\numu\n')
					#print(umu)
					
					for (ufu in ufus)
						
						{
						
						### Subset to a single feature unit
						
						tobj = objtable[which(objtable$FU==ufu),]
						
						### Do some calculation
						
						value = tobj$remainobj * tobj$rarity
						
						#save.image('All.Rdata')
						
						#cat('\nvalue\n')
						#print(value)
					
						#cat('\nufu\n')
						#print(ufu)
					
						### Bind this data into a dataframe
						
						tout = data.frame(MU=umu,FU=ufu,value=value)
						
						### Bind this data to 'out'
						
						out = rbind(out,tout)
						
						}
					
					}
					
				### Close loop
		
				### Aggregate out by summing all values within MU's
				
				outag = aggregate(out$value,by=list(MU=out$MU),FUN=sum)
				
				### Change a name
				
				names(outag)[2] = 'sumvalue'

				### Reorder 'outag' by conservation value
				
				outag = outag[rev(order(outag$sumvalue)),]
				
				### Print
				
				cat('\nOutAg Before New MUs Are Locked In\n',sep='')
				print(outag)
				
				# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

				tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
				
				### Progress
				
				cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')
				
				### Update newly locked in MU in 'objtable'

				locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
				names(locktable)[3] = 'lockedarea'
				
				### Merge locktable and objtable by FU
				
				mergetable = merge(locktable,objtable,by='FU')
				mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
				
				### Remove FU's from merge table where status is zero, only if they also have some area locked in
				
				out2 = NULL
				
				for (fu in unique(mergetable$FU))
				
					{
					
					### Subset
					
					tm = mergetable[which(mergetable$FU==fu),]
					
					if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
					
					out2 = rbind(out2,tm)
					
					}
					
				objtable = out2
				
				### Print
				
				cat('\nObjTable After Locking In MUs\n',sep='')
				print(objtable)
				
				### Calculate proportion of managment units locked in
				### This should be done only for management units interesting PU inv
				### However, we then calculate area for these MU's across all PU's
				
				### Start by subsetting tdata to only PU 'inv'
				
				ttdata = tdata[which(tdata[,'PU']==inv),]
				
				### Determine the Managment Units which interest PU 'inv'
				
				ttumus = unique(ttdata[,'MU'])
				
				### Subset tdata by only the management units in ttumus
				
				tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

				### Now find the sum of the areas for these management units where status is 23
				
				numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
				
				denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
				### Calculate the area that has been 'locked in'
				
				currentproplocked = (numerator/denominator)*100
				
				cat('\nNumerator,Denominator, and CPL\n',sep='')
				print(numerator)
				print(denominator)
				print(currentproplocked)

				### Using a while loop to achieve the target
				
				### Create copies of key tables
				
				outagorig = outag
				
				### Testing line
				
				check = unique(tdata[,'MU'][which(tdata[,'status']==2)])

				while(currentproplocked<target)
				
					{
					
					### Remove the 'lockedarea' field from objtable, otherwise it will fuck up the merge inside this while loop
					
					objtable = objtable[,-c(2,3)] ############ SEARCH HERE ###########
					
					### Print
					
					cat('\nObjTable Before Locking In Further Units\n',sep='')
					print(objtable)
					
					### Identify the management unit with the highest value
					
					muhv = outag$MU[1]
					
					### Print
					
					cat('\nHighest Value Management Unit\n',sep='')
					print(muhv)
					
					### Find all the management units which neighbor MUHV
					
					m1 = grep(muhv,mubound[,1])
					m2 = grep(muhv,mubound[,2])
					mpos = mubound[unique(m1,m2),]
					neighbors = unique(c(mpos$MUID1,mpos$MUID2))
					
					### Print
					
					cat('\nAll Neighbors of MUHV\n',sep='')
					print(neighbors)
				
					### Conditional stuff
					
					if(length(unique(outag$MU %in% neighbors))==2) # Neighboring MU's remain
					
						{
						
						### Print
						
						cat('\nNot All MUs in Outag Are Neighbors of MUHV\n',sep='')
					
						### Eliminate neighbors from outag
						
						outag = outag[-which(outag$MU %in% neighbors),]
						
						### Print
						
						cat('\nOutAg After Removing Neighbors\n',sep='')
						print(outag)
						
						# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

						tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
						
						### Progress
						
						cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')

						### Update newly locked in MU in 'objtable'

						locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
						names(locktable)[3] = 'lockedarea'
						
						### Merge locktable and objtable by FU
						
						mergetable = merge(locktable,objtable,by='FU')
						mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
						
						### Remove FU's from merge table where status is zero, only if they also have some area locked in
						
						out2 = NULL
						
						for (fu in unique(mergetable$FU))
						
							{
							
							### Subset
							
							tm = mergetable[which(mergetable$FU==fu),]
							
							if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
							
							out2 = rbind(out2,tm)
							
							}
							
						objtable = out2
						
						### Print
						
						cat('\nObjTable After Updating MU Status\n',sep='')
						print(objtable)
						
						### Calculate proportion of managment units locked in
						### This should be done only for management units interesting PU inv
						### However, we then calculate area for these MU's across all PU's
						
						### Start by subsetting tdata to only PU 'inv'
						
						ttdata = tdata[which(tdata[,'PU']==inv),]
						
						### Determine the Managment Units which interest PU 'inv'
						
						ttumus = unique(ttdata[,'MU'])
						
						### Subset tdata by only the management units in ttumus
						
						tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

						### Now find the sum of the areas for these management units where status is 23
						
						numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
						
						denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
						### Calculate the area that has been 'locked in'
				
						currentproplocked = (numerator/denominator)*100
						
						### Print
						
						cat('\nNumerator,Denominator, and CPL\n',sep='')
						print(numerator)
						print(denominator)
						print(currentproplocked)

						### Print out a counter

						
						} else { ### In this instance, the management units in outag are all neighbors
						
						cat('\nAll MUs in OutAg Are Neighbors of MUHV\n',sep='')
						
						### Identify the MU's in tdata which are 'locked in'
						
						lockedunits = unique(tdata[,'MU'][which(tdata[,'status']==2)])
						
						### Recreate outag, by removing only the lockedunits from outagorig
						
						outag = outagorig[-which(outagorig$MU %in% lockedunits),]
						
						### Print
						
						cat('\nOutAg With Locked MUs Removed\n',sep='')
						print(outag)
						
						# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

						tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
						
						### Progress
						
						cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')

						### Update newly locked in MU in 'objtable'

						locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
						names(locktable)[3] = 'lockedarea'
						
						### Merge locktable and objtable by FU
						
						mergetable = merge(locktable,objtable,by='FU')
						mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
						
						### Remove FU's from merge table where status is zero, only if they also have some area locked in
						
						out2 = NULL
						
						for (fu in unique(mergetable$FU))
						
							{
							
							### Subset
							
							tm = mergetable[which(mergetable$FU==fu),]
							
							if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
							
							out2 = rbind(out2,tm)
							
							}
							
						objtable = out2
						
						### Print
						
						cat('\nObjTable After Updating MU Status\n',sep='')
						print(objtable)
						
						### Calculate proportion of managment units locked in
						### This should be done only for management units interesting PU inv
						### However, we then calculate area for these MU's across all PU's
						
						### Start by subsetting tdata to only PU 'inv'
						
						ttdata = tdata[which(tdata[,'PU']==inv),]
						
						### Determine the Managment Units which interest PU 'inv'
						
						ttumus = unique(ttdata[,'MU'])
						
						### Subset tdata by only the management units in ttumus
						
						tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

						### Now find the sum of the areas for these management units where status is 23
						
						numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
						
						denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
						### Calculate the area that has been 'locked in'
				
						currentproplocked = (numerator/denominator)*100
						
						cat('\nNumerator,Denominator, and CPL\n',sep='')
						print(numerator)
						print(denominator)
						print(currentproplocked)

						} # End of else condition
					
					}
					
				### End of while loop here, i.e. target has been reached for the planning unit 'inv'
			
				### Now calculate the area of all PU's which has been locked in as a result of locking in area for the planning unit 'inv'
				
				pulock = aggregate(tdata[,'area'][which(tdata[,'status']==2)],by=list(PU=tdata[,'PU'][which(tdata[,'status']==2)],status=tdata[,'status'][which(tdata[,'status']==2)]),FUN=sum)
				names(pulock)[3] = 'lockedarea'
				
				cat('\n Area Locked For PUs\n',sep='')
				print(pulock)
				
								
				} else if (invpos>1 & inv%in%pulock$PU) { # The investigative unit already has some area locked in
				
				### Report progress
				
				cat('\nInvestigating Planning Unit With Some Management Units Already Locked In\n',sep='')
				
				tlockedarea = pulock$lockedarea[which(pulock$PU==inv)] # How much area is already locked in this PU?
				tputhresh = putf$PUthresh[which(putf$PU==inv)]
				
				### Remove fields status and locked area from objtable or they will mess up the merge with lock table
				
				objtable = objtable[,-c(2:3)]
				
				### Print
				
				cat('\nObjTable Before Locking In Units\n',sep='')
				print(objtable)
				
				if (tlockedarea<tputhresh) { # Less than 50% of the area of this investigative unit is locked in, proceed as normal
				
				#### Report progress
				
				cat('\n Less Than Half Of The Planning Unit Has Been Locked In\n',sep='')
				
				### Subsetting to a single planning unit	
			
				puinvest = tdata[which(tdata[,'PU']==inv),]
				
				### Subset the combinations of MU and PU by this planning unit
				
				tmupu = mupus[which(mupus$PU==inv),]
			
				# Now want to summarise this by MU ID and FU ID and area
			
				puinvest = aggregate(puinvest[,'area'], by=list(FU=puinvest[,'FU'], MU=puinvest[,'MU'], PU=puinvest[,'PU']),sum)
			
				# Now to assess the conservation value of each intersecting MU
				### To do this, use a loop
			
				### Identify unique MU's in 'puinvest'
			
				umus = unique(puinvest$MU)
			
				### Create a blank object for binding data to
			
				out = NULL
			
				for (umu in umus)
			
					{
					
					### Subset to only the management unit 'umu'
					
					tpu1 = puinvest[which(puinvest$MU==umu),]
					
					### Get the unique feature units from 'tpu1'
					
					ufus = unique(tpu1$FU)
					
					for (ufu in ufus)
						
						{
						
						### Subset to a single feature unit
						
						tobj = objtable[which(objtable$FU==ufu),]
						
						### Do some calculation
						
						value = tobj$remainobj * tobj$rarity
						
						### Bind this data into a dataframe
						
						tout = data.frame(MU=umu,FU=ufu,value=value)
						
						### Bind this data to 'out'
						
						out = rbind(out,tout)
						
						}
					
					}
					
				### Close loop
		
				### Aggregate out by summing all values within MU's
				
				outag = aggregate(out$value,by=list(MU=out$MU),FUN=sum)
				
				### Change a name
				
				names(outag)[2] = 'sumvalue'

				### Reorder 'outag' by conservation value
				
				outag = outag[rev(order(outag$sumvalue)),]
				
				### Print
				
				cat('\nOutAg Before Locking In MUs\n',sep='')
				print(outag)
				
				# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

				tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
				
				### Progress
				
				cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')
				
				### Update newly locked in MU in 'objtable'

				locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
				names(locktable)[3] = 'lockedarea'
				
				### Merge locktable and objtable by FU
				
				mergetable = merge(locktable,objtable,by='FU')
				mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
				
				### Remove FU's from merge table where status is zero, only if they also have some area locked in
				
				out2 = NULL
				
				for (fu in unique(mergetable$FU))
				
					{
					
					### Subset
					
					tm = mergetable[which(mergetable$FU==fu),]
					
					if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
					
					out2 = rbind(out2,tm)
					
					}
					
				objtable = out2
				
				### Print
				
				cat('\nObjTable After Updating MU Status\n',sep='')
				print(objtable)
				
				### Calculate proportion of managment units locked in
				### This should be done only for management units interesting PU inv
				### However, we then calculate area for these MU's across all PU's
				
				### Start by subsetting tdata to only PU 'inv'
				
				ttdata = tdata[which(tdata[,'PU']==inv),]
				
				### Determine the Managment Units which interest PU 'inv'
				
				ttumus = unique(ttdata[,'MU'])
				
				### Subset tdata by only the management units in ttumus
				
				tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

				### Now find the sum of the areas for these management units where status is 23
				
				numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
				
				denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
				### Calculate the area that has been 'locked in'
				
				currentproplocked = (numerator/denominator)*100
				
				cat('\nNumerator,Denominator, and CPL\n',sep='')
				print(numerator)
				print(denominator)
				print(currentproplocked)
				
				### Using a while loop to achieve the target
				
				### Create copies of key tables
				
				outagorig = outag
				
				### Testing line
				
				#check = unique(tdata[,'MU'][which(tdata[,'status']==2)])

				while(currentproplocked<target)
				
					{
					
					### Remove the 'lockedarea' field from objtable, otherwise it will fuck up the merge inside this while loop
					
					objtable = objtable[,-c(2,3)] ############ SEARCH HERE ###########
					
					### Print
					
					cat('\nObjTable Before Locking In Further MUs\n',sep='')
					print(objtable)
					
					### Identify the management unit with the highest value
					
					muhv = outag$MU[1]
					
					### Print
					
					cat('\nHighest Value Management Unit\n',sep='')
					print(muhv)
					
					### Find all the management units which neighbor MUHV
					
					m1 = grep(muhv,mubound[,1])
					m2 = grep(muhv,mubound[,2])
					mpos = mubound[unique(m1,m2),]
					neighbors = unique(c(mpos$MUID1,mpos$MUID2))
					
					### Print
					
					cat('\nAll Neighbors of MUHV\n',sep='')
					print(neighbors)
				
					### Conditional stuff
					
					if(length(unique(outag$MU %in% neighbors))==2)
					
						{
						
						cat('\nNot All MUs in Outag Are Neighbors of MUHV\n',sep='')
					
						### Eliminate neighbors from outag
						
						outag = outag[-which(outag$MU %in% neighbors),]
						
						### Print
						
						cat('\nOutAg After Removing Neighbors\n',sep='')
						print(outag)
						
						# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

						tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
						
						### Progress
						
						cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')

						### Update newly locked in MU in 'objtable'

						locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
						names(locktable)[3] = 'lockedarea'
						
						### Merge locktable and objtable by FU
						
						mergetable = merge(locktable,objtable,by='FU')
						mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
						
						### Remove FU's from merge table where status is zero, only if they also have some area locked in
						
						out2 = NULL
						
						for (fu in unique(mergetable$FU))
						
							{
							
							### Subset
							
							tm = mergetable[which(mergetable$FU==fu),]
							
							if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
							
							out2 = rbind(out2,tm)
							
							}
							
						objtable = out2
						
						### Print
						
						cat('\nObjTable After Updateing MU Status\n',sep='')
						print(objtable)
						
						### Calculate proportion of managment units locked in
						### This should be done only for management units interesting PU inv
						### However, we then calculate area for these MU's across all PU's
						
						### Start by subsetting tdata to only PU 'inv'
						
						ttdata = tdata[which(tdata[,'PU']==inv),]
						
						### Determine the Managment Units which interest PU 'inv'
						
						ttumus = unique(ttdata[,'MU'])
						
						### Subset tdata by only the management units in ttumus
						
						tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

						### Now find the sum of the areas for these management units where status is 23
						
						numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
						
						denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
						### Calculate the area that has been 'locked in'
				
						currentproplocked = (numerator/denominator)*100
						
						cat('\nNumerator,Denominator, and CPL\n',sep='')
						print(numerator)
						print(denominator)
						print(currentproplocked)

						} else { ### In this instance, the management units in outag are all neighbors
						
						cat('\nAll MUs in OutAg Are Neighbors of MUHV\n',sep='')
						
						### Identify the MU's in tdata which are 'locked in'
						
						lockedunits = unique(tdata[,'MU'][which(tdata[,'status']==2)])
						
						### Recreate outag, by removing only the lockedunits from outagorig
						
						outag = outagorig[-which(outagorig$MU %in% lockedunits),]
						
						### Print
						
						cat('\nOutAg After Removing Locked Units\n',sep='')
						print(outag)
						
						# Take 'highest value' MU (first row in 'outag' object); lock in by changing status to '2' in tdata

						tdata[,'status'][tdata[,'MU']==(outag[1,1])] = 2
						
						### Progress
						
						cat('\nManagement Unit ',outag[1,1],' Locked In\n',sep='')

						### Update newly locked in MU in 'objtable'

						locktable = aggregate(tdata[,'area'], by=list(FU=tdata[,'FU'], status=tdata[,'status']),sum)
						names(locktable)[3] = 'lockedarea'
						
						### Merge locktable and objtable by FU
						
						mergetable = merge(locktable,objtable,by='FU')
						mergetable$remainobj[which(mergetable$status==2)] = 30-(mergetable$lockedarea[which(mergetable$status==2)]/mergetable$objarea[which(mergetable$status==2)])
						
						### Remove FU's from merge table where status is zero, only if they also have some area locked in
						
						out2 = NULL
						
						for (fu in unique(mergetable$FU))
						
							{
							
							### Subset
							
							tm = mergetable[which(mergetable$FU==fu),]
							
							if(nrow(tm)>1){tm = tm[which(tm$status==2),]}
							
							out2 = rbind(out2,tm)
							
							}
							
						objtable = out2
						
						### Print
						
						cat('\nObjTable After Updating MU Status\n',sep='')
						print(objtable)
						
						### Calculate proportion of managment units locked in
						### This should be done only for management units interesting PU inv
						### However, we then calculate area for these MU's across all PU's
						
						### Start by subsetting tdata to only PU 'inv'
						
						ttdata = tdata[which(tdata[,'PU']==inv),]
						
						### Determine the Managment Units which interest PU 'inv'
						
						ttumus = unique(ttdata[,'MU'])
						
						### Subset tdata by only the management units in ttumus
						
						tttdata = tdata[which(tdata[,'MU'] %in% ttumus),]

						### Now find the sum of the areas for these management units where status is 23
						
						numerator = sum(tttdata[,'area'][which(tttdata[,'status']==2)])
						
						denominator = putf$PUthresh[which(putf$PU==inv)]*2
				
						### Calculate the area that has been 'locked in'
				
						currentproplocked = (numerator/denominator)*100
						
						cat('\nNumerator,Denominator, and CPL\n',sep='')
						print(numerator)
						print(denominator)
						print(currentproplocked)
						
						} # End of else condition
					
					}
					
				### End of while loop here, i.e. target has been reached for the planning unit 'inv'
			
				### Now calculate the area of all PU's which has been locked in as a result of locking in area for the planning unit 'inv'
				
				pulock = aggregate(tdata[,'area'][which(tdata[,'status']==2)],by=list(PU=tdata[,'PU'][which(tdata[,'status']==2)],status=tdata[,'status'][which(tdata[,'status']==2)]),FUN=sum)
				names(pulock)[3] = 'lockedarea'
				
				### Print
				
				cat('\n Area Locked For PUs\n',sep='')
				print(pulock)
				
				} else { # More than 50% of this planning unit has been 'locked in'
				
				### Report progress
				
				cat('\nMore Than 50% Of This Planning Unit Is Locked In\n',sep='')
				
				### Identify the PU's which neighbor 'inv'
					
				p1 = grep(inv,pubound[,1])
				p2 = grep(inv,pubound[,2])
				ppos = pubound[unique(p1,p2),]
				pneighbors = unique(c(ppos$PUID1,ppos$PUID2))
				pneighbors = pneighbors[-which(pneighbors==inv)]
				
				### Print
				
				cat('\nNeighboring Planning Units\n',sep='')
				print(pneighbors)
				
				### Find the neighbor which shares the longest boundary with 'inv'
				
				pnout = NULL
				
				for (nn in pneighbors)
				
					{
					
					tbound = pubound$boundary[which(pubound[,1]==nn & pubound[,2]==inv)]
					tpnout = data.frame(PUID=nn,bound=tbound)
					pnout = rbind(tpnout,pnout)
					
					}
					
				### Identify the Planning Unit with the longest shared boundary with 'inv'
				
				NPUID = pnout$PUID[which(pnout$bound==max(pnout$bound))]
				
				### Print
				
				cat('\nUpdating PU ',inv,' To ',NPUID,'\n',sep='')
				
				### Update the Planning Unit 'inv' to NPUID in the table tdata
				
				tdata[,'PU'][which(tdata[,'PU']==inv)]=NPUID
				
				### Now recalculate the locked in area for all planning units
				
				pulock = aggregate(tdata[,'area'][which(tdata[,'status']==2)],by=list(PU=tdata[,'PU'][which(tdata[,'status']==2)],status=tdata[,'status'][which(tdata[,'status']==2)]),FUN=sum)
				names(pulock)[3] = 'lockedarea'
				
				cat('\n Area Locked For PUs\n',sep='')
				print(pulock)
				
			
				### Adjust the threshold area for all PUs

				### Create a table of thresholds based on planning unit size

				putf = aggregate(tdata[,'area'],by=list(PU=tdata[,'PU']), FUN=sum)
				names(putf)[2] = 'PUthresh'
				putf$PUthresh = putf$PUthresh/2	

				### Adjust the neighbors table 'pubound', by updated planning unit 'inv' to NPUID
				
				pubound$PUID1[which(pubound$PUID1==inv)] = NPUID
				pubound$PUID2[which(pubound$PUID1==inv)] = NPUID
				
				### Adjust the table 'mupus', unique  by updated planning unit 'inv' to NPUID
				
				mupus$PU[which(mupus$PU==inv)] = NPUID
				
				### Here we need to recalculate boundary lengths
				
				
				}
				
				} 
				
			cat('\nFinished Investigating Planning Unit ',inv,'\n',sep='')
			
			}
			
			# Finished investigating all planning units in one iteration
			
	### Adjust the planning unit ID's of units in tdata which are locked in

	tdata[,'PU'][which(tdata[,'status']==2)] = as.numeric(tdata[,'PU'][which(tdata[,'status']==2)])+3000
			
	### Create the input files
		
	write.inputs(id)
	twrite2(create.input.dat(od,id,ii),paste('input',sprintf('%03i',ii),'.dat',sep=''))
	twrite2(create.spec.dat(),file.path(id,'/spec.dat'))
	
	### Report progress
	
	cat('\nStarting Marxan Iteration ',ii,'\n',sep='')
	
	if(ii==2){save.image('All2.Rdata')}
	#if(ii==3){save.image('All3.Rdata')}
	if(ii==4){save.image('All4.Rdata')}
	
	### Run Marxan
	
	system(command=paste('./MarOpt_v243_Linux64 input',sprintf('%03i',ii),'.dat -s ',sep=''))
	
	### Adjust the iteration counter
	
	ii = ii + 1
	
	}
	
cat('\nFinished Simulation\n',sep='')

### Simulation complete
